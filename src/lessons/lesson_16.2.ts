/**
 * Паттерни програмування
 *
 * Патерни програмування — це повторювані архітектурні рішення для типових проблем у
 * проектуванні ПЗ.
 *
 * Вони являють собою впізнавані структури і шаблони, які можна використовувати для
 * створення ефективних, гнучких і перевикористовуваних програмних систем.
 *
 * Патерни допомагають розробникам справлятися зі складнощами проектування,
 * полегшують комунікацію між розробниками і роблять код більш зрозумілим і підтримуваним.
 */

/**
 * Деякі ключові причини використання патернів:
 *
 * Повторне використання коду.
 * Патерни програмування надають готові архітектурні рішення для типових завдань,
 * що дає змогу розробникам використовувати перевірені й оптимальні підходи до розв'язання проблем.
 *
 * Покращення розуміння коду.
 * Вони є впізнаваними шаблонами, які покращують читабельність коду. Це робить код зрозумілішим
 * і полегшує спільну співпрацю розробників.
 *
 * Підвищення гнучкості та розширюваності.
 * Патерни допомагають розділити систему на окремі компоненти, що робить її гнучкішою і
 * дає змогу легко додавати нову функціональність або змінювати поведінку без необхідності
 * переписувати більшу частину коду.
 *
 * Забезпечення структурованості.
 * Патерни надають структуровані методи для розв'язання певних завдань, що дозволяє
 * легше підтримувати та масштабувати код системи.
 *
 * Спільна мова та архітектура.
 * Використання знайомих патернів дає змогу команді розробників спілкуватися спільною мовою
 * та використовувати загальні архітектурні принципи, що підвищує ефективність роботи
 * та якість коду.
 *
 *
 * Усі ці переваги зробили їх важливим інструментом у розробці та роблять ПЗ більш якісним,
 * що є ключовим фактором для успішних проектів.
 */

/**
 * Паттерни GoF
 *
 * Патерни GoF (Gang of Four patterns) — це набір із 23 основних патернів програмування,
 * представлених у книзі «Design Patterns: Elements of Reusable Object-Oriented Software».
 *
 * Книгу було видано 1994 року і вона стала класикою в галузі програмування.
 * Вона представляє 23 різні патерни програмування, які були сформульовані,
 * щоб розв'язати типові проблеми в проектуванні об'єктно-орієнтованих систем.
 *
 * Кожен паттерн GoF має опис проблеми, яку він розв'язує, структуру розв'язання та
 * приклади його застосування.
 */

/**
 * Усі патерни GoF поділено на три групи:
 *
 * 1. Структурні
 * 2. Поведінкові
 * 3. Породжувальні
 */

/**
 * Структурні
 *
 * Структурні патерни займаються композицією об'єктів і класів для створення більших структур
 * і спрощення їхньої роботи.
 *
 * Ці патерни дозволяють змінювати структуру системи, забезпечуючи її гнучкість і розширюваність
 * без зміни самого коду. Вони часто використовуються для зв'язування різних компонентів системи,
 * щоб вони могли працювати разом, незалежно від своєї структури.
 */

/**
 * Поведінкові
 *
 * Поведінкові патерни займаються взаємодією об'єктів і класів, визначаючи образ,
 * у якому вони спілкуються і співпрацюють між собою.
 *
 * Ці патерни розв'язують питання організації взаємодії об'єктів, роблячи систему більш гнучкою
 * і стійкою до змін.
 *
 * Основна мета поведінкових патернів — поліпшити комунікацію між об'єктами,
 * щоб код став більш чистим і підтримуваним.
 */

/**
 * Породжуючі
 *
 * Патерни, що породжують, в об'єктно-орієнтованому програмуванні займаються механізмами
 * створення об'єктів і управління цим процесом.
 *
 * Ці патерни дають змогу зменшити залежність між клієнтським кодом і створюваними об'єктами,
 * роблячи систему гнучкішою та стабільною.
 *
 * Основною метою породжувальних патернів є приховування складних процесів створення об'єктів і
 * надання клієнтському коду простого інтерфейсу для створення екземплярів.
 */

/**
 * Паттерн «Фасад»
 *
 * Паттерн «Фасад» (Facade) — це структурний паттерн проєктування,
 * який надає простий інтерфейс для взаємодії зі складнішою підсистемою.
 *
 * «Фасад» обертає групу об'єктів, надаючи клієнту спрощений інтерфейс для взаємодії з ними.
 *
 * Це дає змогу знизити складність системи та спростити взаємодію з нею,
 * приховуючи деталі реалізації.
 */

/**
 * Проблема
 *
 * Проблема виникає, коли вашому коду доводиться працювати з великою кількістю об'єктів
 * складної бібліотеки або фреймворку.
 *
 * Ви повинні самостійно ініціалізувати ці об'єкти, стежити за правильним порядком залежностей тощо.
 * У результаті бізнес-логіка ваших класів тісно переплітається з деталями реалізації
 * сторонніх класів.
 *
 * Такий код досить складно розуміти і підтримувати.
 */

/**
 * Рішення
 *
 * «Фасад» — це простий інтерфейс для роботи зі складною підсистемою, що містить безліч класів.
 *
 * Він може мати урізаний інтерфейс, який не має 100% функціональності, якої можна досягти,
 * використовуючи складну підсистему безпосередньо. Але він надає саме ті методи,
 * які потрібні клієнту, і приховує всі інші.
 *
 * Так само "Фасад" корисний, якщо ви використовуєте якусь складну бібліотеку з безліччю
 * функціональності, але вам потрібна тільки частина її можливостей.
 */

/**
 * Структура
 *
 * Патерн складається з таких «частин»:
 *
 * Фасад.
 * Фасад надає швидкий доступ до певної функціональності підсистеми.
 * Він «знає», яким класам потрібно переадресувати запит, і які дані для цього потрібні.
 *
 * Додатковий фасад.
 * Його можна ввести, щоб не «засмічувати» єдиний фасад різнорідною функціональністю.
 * Він може використовуватися як клієнтом, так і іншими фасадами.
 *
 * Складна підсистема.
 * Підсистема складається з безлічі різноманітних класів. Для того, щоб змусити їх щось робити,
 * потрібно знати подробиці будови підсистеми, порядок ініціалізації об'єктів тощо.
 * Класи підсистеми не знають про існування фасаду і працюють один з одним безпосередньо.
 *
 * Клієнт.
 * Клієнт використовує фасад замість прямої роботи з об'єктами складної підсистеми.
 */

/**
 * Кроки реалізації
 *
 * 1. Визначте, чи можна створити простіший інтерфейс, ніж той, який надає складна підсистема.
 *    Ви на правильному шляху, якщо цей інтерфейс позбавить клієнта необхідності знати
 *    про подробиці підсистеми.
 *
 * 2. Створіть клас фасаду, що реалізує цей інтерфейс. Він має переадресовувати виклики клієнта
 *    потрібним об'єктам підсистеми.
 *    Фасад повинен буде подбати про те, щоб правильно ініціалізувати об'єкти підсистеми.
 *
 * 3. Ви отримаєте максимум користі, якщо клієнт працюватиме тільки з фасадом.
 *    У цьому разі зміни в підсистемі зачіпатимуть тільки код фасаду, а клієнтський код залишиться
 *    робочим.
 *
 * 4. Якщо відповідальність фасаду починає розмиватися, подумайте про введення додаткових фасадів.
 */

// Приклад 1. Концептуальний приклад
{
    /**
     * Підсистема може приймати запити або від фасаду, або від клієнта безпосередньо.
     * У будь-якому разі, для підсистеми фасад - це ще один клієнт, і він не є
     * частиною підсистеми.
     */

    class SubsystemA {
        operation1(): string {
            return 'SubsystemA: Ready!\n';
        }

        // ...
        operationN(): string {
            return 'SubsystemA: Go!\n';
        }
    }

    /**
     * Деякі фасади можуть працювати з різними підсистемами одночасно.
     */
    class SubsystemB {
        operation1(): string {
            return 'SubsystemB: Get ready!\n';
        }

        // ...
        operationX(): string {
            return 'SubsystemB: Fire!';
        }
    }

    /**
     * Клас Фасаду надає простий інтерфейс для складної логіки однієї або
     * кількох підсистем. Фасад делегує запити клієнтів відповідним
     * об'єктам усередині підсистеми. Фасад також відповідає за управління їхнім життєвим
     * циклом. Усе це захищає клієнта від небажаної складності підсистеми.
     */
    class Facade {
        private readonly subsystemA: SubsystemA;
        private readonly subsystemB: SubsystemB;

        /**
         * Залежно від потреб вашого додатка ви можете надати Фасаду наявні об'єкти підсистеми
         * або змусити Фасад створити їх самостійно.
         */
        constructor(subsystemA?: SubsystemA, subsystemB?: SubsystemB) {
            this.subsystemA = subsystemA || new SubsystemA();
            this.subsystemB = subsystemB || new SubsystemB();
        }

        /**
         * Методи Фасаду зручні для швидкого доступу до складної функціональності
         * підсистем. Однак клієнти отримують тільки частину можливостей підсистеми.
         */
        operation(): string {
            let result = 'Facade initializes subsystems:\n';
            result += this.subsystemA.operation1();
            result += this.subsystemB.operation1();
            result += 'Facade orders subsystems to perform the action:\n';
            result += this.subsystemA.operationN();
            result += this.subsystemB.operationX();

            return result;
        }
    }

    /**
     * Клієнтський код працює зі складними підсистемами через простий інтерфейс,
     * що надається Фасадом. Коли фасад керує життєвим циклом підсистеми,
     * клієнт може навіть не знати про існування підсистеми. Такий підхід дає змогу
     * тримати складність під контролем.
     */
    function clientCode(facade: Facade) {
        // ...

        console.log(facade.operation());

        // ...
    }

    /**
     * У клієнтському коді можуть бути вже створені деякі об'єкти підсистеми. У цьому
     * випадку може виявитися доцільним ініціалізувати Фасад із цими
     * об'єктами замість того, щоб дозволити Фасаду створювати нові екземпляри.
     */
    const subsystem1 = new SubsystemA();
    const subsystem2 = new SubsystemB();
    const facade = new Facade(subsystem1, subsystem2);
    clientCode(facade);
}

// Приклад 2. Приклад із життя
{
    interface IBankClient {
        readonly firstName: string;
        readonly lastName: string;
    }

    class BankClient implements IBankClient {
        constructor(
            private readonly _firstName: string,
            private readonly _lastName: string,
            private readonly _age: number,
            private _accountNumber: number | null = null,
        ) {}

        get accountNumber(): number {
            if (!this._accountNumber) throw new Error('New client');

            return this._accountNumber;
        }

        set accountNumber(value: number) {
            this._accountNumber = value;
        }

        get age(): number {
            return this._age;
        }

        get firstName(): string {
            return this._firstName;
        }

        get lastName(): string {
            return this._lastName;
        }
    }

    class BankAccount {
        private readonly _number: number;
        private balance = 0;
        private _holderName!: string;

        constructor(client: IBankClient, private readonly currency: string) {
            this.currency = currency;
            this.#setHolderName(client);
            this._number = 12345678;
        }

        get balanceInfo(): string {
            return `${this.currency}${this.balance}`;
        }

        get holderName(): string {
            return this._holderName;
        }

        get number(): number {
            return this._number;
        }

        #setHolderName({ firstName, lastName }: IBankClient) {
            if (!firstName.trim()) throw new Error(`Client first name can't be empty!`);
            if (!lastName.trim()) throw new Error(`Client last name can't be empty!`);

            this._holderName = `${lastName} ${firstName}`;
        }

        deposit(amount: number): void {
            this.balance += amount;
        }

        withdraw(amount: number): void {
            if (this.balance < amount) throw new Error(`Sorry ${this._holderName}, you don't have enough funds!`);

            this.balance -= amount;
        }
    }

    class SalaryDataProvider {
        getAnnualSalary(client: BankClient): number {
            // Тут припустимо, що ми отримуємо дані про зарплату клієнта за 12 місяців
            // Повертаємо деяке фіктивне значення
            return 50000;
        }
    }

    class CreditHistoryProvider {
        getCreditRating(client: BankClient): number {
            // Тут припустимо, що ми отримуємо рейтинг кредитної історії клієнта від 1 до 3
            // Повертаємо деяке фіктивне значення
            return 2;
        }
    }

    // Фасад
    class Bank {
        private readonly accounts!: Record<number, BankAccount>;
        private readonly creditHistoryProvider: CreditHistoryProvider;
        private readonly salaryDataProvider: SalaryDataProvider;

        constructor() {
            // вид звязку?
            this.creditHistoryProvider = new CreditHistoryProvider();
            this.salaryDataProvider = new SalaryDataProvider();
        }

        addAccount(client: BankClient): void {
            const account = new BankAccount({ firstName: client.firstName, lastName: client.lastName }, '');
            client.accountNumber = account.number;

            this.accounts[client.accountNumber] = account;
        }

        deposit(client: BankClient, amount: number): void {
            const account = this.getAccount(client);
            account.deposit(amount);
        }

        withdraw(client: BankClient, amount: number): void {
            const account = this.getAccount(client);
            account.withdraw(amount);
        }

        getCreditDecision(client: BankClient, amount: number, duration: number): boolean {
            const salary = this.salaryDataProvider.getAnnualSalary(client);
            const creditRating = this.creditHistoryProvider.getCreditRating(client);

            // Dificult calculations...

            return true;
        }

        private getAccount(client: BankClient): BankAccount {
            return this.accounts[client.accountNumber];
        }
    }

    /**
     * Паттерн «Фасад» тут реалізовано за допомогою класу Bank,
     * який надає простий інтерфейс для роботи з банком.
     *
     * Замість того, щоб безпосередньо взаємодіяти з різними класами та складними розрахунками,
     * клієнти можуть використовувати методи addAccount, deposit, withdraw і getCreditDecision
     * класу Bank, що робить роботу з банком зручнішою та зрозумілішою.
     *
     * Внутрішні деталі та складні розрахунки (як-от отримання кредитного рейтингу або зарплати)
     * приховані всередині Bank та його допоміжних класів.
     *
     * Пам'ятайте, що це лише приклад, і реалізація деяких методів може бути фіктивною.
     * У реальній системі дані мають бути отримані з надійних джерел.
     */
}

/**
 * Переваги
 *
 * Спрощення взаємодії.
 * «Фасад» надає зручний інтерфейс, з яким легко працювати клієнту. Він приховує складну
 * структуру системи і надає тільки необхідний функціонал.
 *
 * Зниження пов'язаності.
 * Такий підхід дає змогу знизити залежності між клієнтом і підсистемою, адже клієнт
 * взаємодіє тільки з фасадом, не переймаючись деталями реалізації.
 *
 * Покращення підтримуваності.
 * «Фасад» дає змогу виділити функціональність, пов'язану з конкретною підсистемою,
 * в окремий компонент. Це спрощує тестування і підтримку системи в цілому.
 */

/**
 * Недоліки
 *
 * Збільшення складності Фасаду.
 * Якщо підсистема має занадто багато функціональності, «Фасад» може стати складним
 * і містити безліч методів, що знизить його ефективність.
 *
 * Обмеженість.
 * Патерн надає тільки обмежений інтерфейс до функціональності підсистеми,
 * і клієнти можуть зіткнутися з обмеженнями, якщо їм знадобиться більш повний доступ
 * до функціональності.
 */
